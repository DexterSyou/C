###
##资料来自网上搜索进行总结
```
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
1. 读取文件 ： 读操作的位置由文件内部位置指针来确定 ，对于已经存在的文件，文件被打开时，文件内部位置指针指向文件的第一个字节。
                如：
                   调用fgetc()函数读的是第一个字节的字符，读入一个字节以后，位置指针将自动向后移动一个字节，
                   那么再调用一次fgetc()函数，则读取的是第2个字符，连续调用该函数就可以读取文件的每个字符，
                   并且可以使用EOF来判断是否已经到了文件末尾 

2.EOF     ：
             EOF 本来表示文件末尾，意味着读取结束
             很多函数在读取出错时也返回 EOF

             由于EOF是一个有效的整型值，当你操作二进制文件时，必须用feof函数进行文件结束检测。同样也必须使用ferror函数进行出错检查   

             feof() 函数用来判断文件内部指针是否指向了文件末尾
             int feof(FILE *fp)   当指向文件末尾时返回非零值，否则返回零值。             
             
             ferror() 函数用来判断文件操作是否出错
             int ferror(FILE *fp) 

3.文件内部的位置指针 ：
        位置指针仅仅是一个标志，表示文件读写到的位置，也就是读写到第几个字节，它不表示地址。
        文件每读写一次，位置指针就会移动一次，它不需要你在程序中定义和赋值，而是由系统自动设置，对用户是隐藏的
     stream文件流指针体指向文件内容地址的偏移原则：
        如果使用fgets()读取某个文件，第一次读取的bufsize为5，而文件的第一行有10个字符（算上'\n'），
        那么读取文件的指针会偏移至当前读取完的这个字符之后的位置。


4.输入缓冲刷新：
        当流被关闭时
        当调用 exit终止程序时
        缓冲区满(linux下默认缓冲区的大小为1024字节)
        主动刷新 fflush(stdout)；
        遇到"\n"会刷新
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
//标准I/O 
//I/O  *****getchar**************************************************************************************
//Primitive Declaration : 
     #include<stdio.h>  
     int getchar(void);
//Input Buff            :  YES 
//Content               :
int getchar(void)
{
  /* 
     工作原理 ： 从stdin流中读入一个字符
                stdin有数据的话不用输入它就可以直接读取了，第一次getchar()时，确实需要人工的输入
                输了多个字符，以后的getchar()再执行时就会直接从缓冲区中读取了 

     DES     ： ***** 输入设备stdin-----> 内存缓冲区 -----> getchar() *****
                键盘输入的字符都存到缓冲区内,一旦键入回车(回车也存入缓冲区),
                getchar()读取每个字符，包括空格、制表符和换行符，getchar就进入缓冲区读取字符,
                一次只返回第一个字符作为getchar函数的值。足够多的getchar语句,就会依次读出缓冲区内的所有字符直到’\n’

     RETURN  ：  getchar函数的返回值是用户输入的字符的ASCII码，
                 若文件结尾(End-Of-File)则返回-1(EOF)，且将用户输入的字符回显到屏幕。
        
     作用    ：1.  清除缓冲区
                   while(getchar()!='\n')continue;
               2.  scanf()在读取输入时会在缓冲区中留下一个字符’\n’（输入完按回车键所致）

  */  
  
    static char buf[BUFSIZ];
    static char* bb=buf;
    static int n=0;
    if(n==0)
    {
        n=read(0,buf,BUFSIZ);
        bb=buf;
    }
    return (--n>=0)?(unsigned char)*bb++:EOF;
  
//Content

//I/O  *****getc**************************************************************************************
//Primitive Declaration : 
     #include<stdio.h>  
     int getc(FILE *stream);
//Input Buff            :  YES 
//Content               :
{
  /* 
     工作原理 ： 用于从指定一个待操作的数据流读取下一个字符并将推进文件的位置指示器（用来指示接下来要读写的下一个字符的位置）。

     RETURN  ：  正常情况下读取到的unsigned char类型转换int型返回
                 如果读取失败或者到了文件结束标志返回EOF(-1)
  */  

//Content

//I/O  *****fgetc******file get char********************************************************************************
//Primitive Declaration : 
     #include<stdio.h>  
     int fgetc(FILE *stream);
//Input Buff            :  YES 
//Content               :
{
  /* 
     工作原理 ： 从文件指针stream指向的文件中读取一个字符，读取一个字节后，光标位置后移一个字节

     RETURN  ： 返回所读取的一个字节。返回值不为unsigned char的原因为，返回值要能表示-1
                如果读到文件末尾或者读取出错时返回EOF。             
  */  
//Content

//I/O  *****fgets**************************************************************************************
//Primitive Declaration : 
     char *fgets(char *str, int n, FILE *stream);
//Input Buff            :  YES 
//Content               :
{
  /* 
     工作原理 ： 从指定的流 stream 读取一行，并把它存储在str所指向的字符串内
                如果文件中的该行（包括最后一个换行符），不足n-1个字符，则读完该行就结束。
                该行（包括最后一个换行符）的字符数超过n-1，则fgets只返回一个不完整的行，缓冲区总是以NULL字符结尾，对fgets的下一次调用会继续读该行。
                函数成功将返回stream，失败或读到文件结尾返回NULL。
                不能直接通过fgets的返回值来判断函数是否是出错而终止的，应该借助feof函数或者ferror函数来判断。
                如果 n 大于字符串的长度则多余的部分系统会自动用 ‘\0’ 填充。。

     DES     ： str      指向一个字符数组的指针，该数组存储了要读取的字符串。  
                n        要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。
                stream   指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流
     
     RETURN  ： 如果成功，该函数返回相同的 str 参数。
                如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。   
                如果发生错误，返回一个空指针。

     在读字符时遇到end-of-file，则eof指示器被设置，如果还没读入任何字符就遇到这种情况，则stream保持原来的内容，返回NULL；   
     如果发生读入错误，error指示器被设置，返回NULL，stream的值可能被改变。                
  */  

//Content

//I/O  *****gets**************************************************************************************
//Primitive Declaration : 
//Input Buff            :  YES 
//Content               :
{
  /* 
     工作原理 ： 从标准输入设备读字符串函数，其可以无限读取，不会判断上限，以回车结束读取
                不会把\n包含到字符串里面去。

     DES     ： str      指向一个字符数组的指针，该数组存储了要读取的字符串。  
                n        要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。
                stream   指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流
     
     RETURN  ： 读入成功，返回与参数buffer相同的指针；
                读入过程中遇到EOF(End-of-File)或发生错误，返回NULL指针  
            

     要用ferror或feof函数检查是发生错误还是遇到EOF。              
  */  

//Content
//I/O*****scanf**************************************************************************************
//Primitive Declaration : 
     #include<stdio.h>  
     int scanf(const char * restrict format,...);
//Input Buff            :  YES 
//Content               :
  /* 
     工作原理 ：函数 scanf() 是从标准输入流stdin [1]  (标准输入设备，一般指向键盘)中读内容的通用子程序，
               可以说明的格式读入多个字符，并保存在对应地址的变量中
               
     RETURN  ：scanf函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回EOF
               scanf只有在遇到\n，也就是是回车时才结束输入，但是遇到空格和tab时就会停止读取
     
     注意问题 ： 
       1. scanf("%[^\n]",str);   //！scanf("%s",string);不能接收空格符
       2. 键盘缓冲区残余信息问题 
          scanf("%c",&c);
          每击打一下"Enter"键，向键盘缓冲区发去一个“回车”(\r),一个“换行"(\n),
          在这里\r被scanf()函数处理掉了，而\n被scanf()函数“错误”地赋给了c
       3. 输入类型与格式化字符串不匹配导致stdin流的阻塞 
            int a=0,b=0,c=0,ret=0;
            ret=scanf("%d%d%d",&a,&b,&c);  //！执行到第一个scanf时，当输入字符’b’的时候与ret=scanf("%d%d%d",&a,&b,&c);中的格式化字符串不匹配，
                                           //  stdin流被阻塞，scanf函数不在读取后面的部分，直接将1返回，
                                           //  表示只将stdin流中的1读入到了变量a中
            printf("第一次读入数量：%d\n",ret)；
            ret=scanf("%d%d%d",&a,&b,&c);  // 执行到第二个scanf时，字符’b’还是与格式化字符串不匹配，stdin流仍然被阻塞
            printf("第二次读入数量：%d\n",ret);

       4.scanf()函数误输入造成程序死锁或出错
         键盘缓冲区就可能还个有残余信息 

       5.fflush(stdin)
       int fflush(FILE *stream);
         C99 对 fflush 函数的定义:
             如果stream指向输出流或者更新流（update stream），并且这个更新流执行的操作不是输入   
             那么fflush函数将把任何未被写入的数据写入stream指向的文件（如标准输出文件stdout）。否则，fflush函数的行为是不确定的
         C和C++的标准里从来没有定义过 fflush(stdin)     
             fflush（NULL）清空所有输出流和上面提到的更新流。如果发生写错误，fflush函数会给那些流打上错误标记，并且返回EOF，否则返回0。

         stream 指向输入流（如 stdin），那么 fflush 函数的行为是不确定的 
  */  
//Content
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
//I/O*****putchar*********file output char ****************************************************************************
//Primitive Declaration : #include<stdio.h>  
//                         int putchar(int char);
//Input Buff            :  YES 
//Content               :

  /* 
     工作原理 ： 把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中
                其输出可以是一个字符，可以是介于0~127之间的一个十进制整型数（包含0和127），也可以是用char定义好的一个字符型变量
  */  
//Content

//I/O  *****putc**************************************************************************************
//Primitive Declaration : 
     #include<stdio.h>  
     int putc(int char, FILE *stream)；
//Input Buff            :  YES 
//Content               :
{
  /* 
     工作原理 ： 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。

     RETURN  ：  该函数以无符号 char 强制转换为 int 的形式返回写入的字符，如果发生错误则返回 EOF。
  */  

//Content

//I/O  *****fputc **************************************************************************************
//Primitive Declaration : 
     #include<stdio.h>  
     int fputc (int c, File *fp)
//Input Buff            :  YES 
//Content               :
{
  /* 
     工作原理 ： 将字符c写到文件指针fp所指向的文件的当前写指针的位置
                当正确写入一个字符或一个字节的数据后，文件内部写指针会自动后移一个字节的位置。
     RETURN  ： 在正常调用情况下，函数返回写入文件的字符的ASCII码值，出错时，返回EOF（-1）。
  */  

//Content

//I/O  *****fputs **************************************************************************************
//Primitive Declaration : 
     #include<stdio.h>  
     int fputs(const char *str, FILE *stream);
//Input Buff            :  YES 
//Content               :
{
  /* 
     工作原理 ： 向指定的文件写入一个字符串（不自动写入字符串结束标记符‘\0’）但不包括空字符。
                成功写入一个字符串后，文件的位置指针会自动后移
     DES     ： str：    这是一个数组，包含了要写入的以空字符终止的字符序列。
                stream： 指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流
     RETURN  ： 函数返回值为非负整数；否则返回EOF(符号常量，其值为-1)。

//Content

//I/O  *****puts **************************************************************************************
//Primitive Declaration : 

//Input Buff            :  YES 
//Content               :
{
  /* 
     工作原理 ： 把字符串输出到标准输出设备，将'\0'转换为回车换行
//Content

//I/O*****printf**************************************************************************************
//Primitive Declaration : 
     #include<stdio.h>  
     int printf(const char *format, ...);
//Input Buff            :  YES 
//Content               :

  /* 
     工作原理 ： 标准化输出
  */  
//Content






---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0
---------9---------8---------7---------6---------5---------4---------3---------2---------1---------0

```
