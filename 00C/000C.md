## C

```
#*******************************************************************************
#0.C
#    Dennis Ritchie Ken Thompson
#    高效，可移植，强大灵活，面向编程人员
#    C的应用领域
#       UNIX操作系统  计算机游戏 嵌入式  机器人  Lucas电影 
#       星球大战电影  计算机语言 PC应用 
#*******************************************************************************
#
#                  SA概要
# 定义程序目标     UI       （一般概念
  设计程序         SS       （一般概念
                    PS
  ---------------------------
  编写代码         PG 
     编译             
     运行             
  测试             PT IT ST OT
  维护             
#
#编译 和 链接
 源代码   经过编译器编译   形成目标代码
 demo.c   ---compile--->   demo.obj
 目标代码 库代码 启动代码        经过链接器链接  形成可执行代码
 demo.obj lib    start-up code   ----link----->  demo.exe           

 cc
 gcc
#
#标准
 The C Programming Language
 C89/C90
 C99
#
#*******************************************************************************
#1.C 数据
#*******************************************************************************
#
#1-1.数据类型
     按在计算机的存储方式为两个系列
	   整数    没有小数的部分的数
	   浮点数  小数部分和指数部分分别存储

   1-1-1.位，字节，字
       用于描述计算机数据单位或计算机存储单位。
	   最小的存储单位，计算机存储的基本单位  位bit
       常用的计算机存储单位                  字节byte  1个字节8位
       自然的存储单位                        字
       
   1-1-2.变量 与 常量数据
     变量的值可以在程序执行过程中的变化与指定，而常量则不可以
 
   1-1-3.进制
     十景之    %d
	 八进制    %o
	 十六进制  %x
#
#1-2.C数据类型
   int 类型
       有符号整数，int类型的值必须是整数，其取值范围依赖于计算机系统
	   ISO/ANSI C 规定int类型的最小范围-32768～32767
     声明int 变量
	     初始化initialize变量就是为变量赋一个初始值
	 int类型常量
     long常量       L
	 long long 常量 LL
	 unsigned 常量  U 
     提供3个附属关键字修饰基本数据类型 short ，long ，unsigned
	 C 保证short类型不会比int类型长，并且long类型不会比int类型短  
#
#1-3.char 类型
     char类型用于存储字母 和 标点符号
	 但是在技术实现上char是整数类型，char类型实际存储的是整数而不是字符
     C把一个字节byte 定义为char类型使用的位bit数
  	 标准ASCII码值的范围0～127
    
	 char变量
	 char常量
#
#1-4.float double 类型
     浮点变量
	 浮点常量

###################
#1-5.内存管理
     作用域：描述了程序中可以访问一个标识符的一个 或 多个区域。
	         代码块作用域
			 函数原型作用域
			 文件作用域
	 链接：外部链接 ： 文件作用域
	       内部链接 ： 文件作用
		   空链接   ：
		               具有代码块作用域  代码块
			           函数原型作用域    函数原型私有
       
	       外部链接可以在一个多文件程序任何地方使用，内部链接的变量
		   可以在一个文件的任何地方使用。

     存储时期：静态存储时期 和 自动存储时期
	    如果一个变量具有静态存储时期，它在程序执行期间将一直存在
		具有文件作用域的变量具有静态存储时期，static表明链接类型，
		并非存储时期。

		具有代码块作用域的变量一般情况下自动存储时期，在程序进入自定义这些变量的代码块时，
		将为这些变量分配内存，当退出这个代码块时，分配的内存将被释放。

    C使用作用域，链接，存储时期定义了5 中存储类
	 存储类                时期       作用域      链接        声明方式
	  自动                 自动       代码块      空          代码块内   
	  寄存器               自动       代码块      空          代码块内，register  
	  具有外部链接的静态   静态       文件        外部链接    所有函数之外，extern  
	  具有内部链接的静态   静态       文件        内部链接    所有函数之外，static
	  空链接的静态         静态       代码块      空          代码块，static
	  
    自动变量
	   函数头部定义，代码块中定义的任意变量
	   使用关键字 auto，需要显示的初始化
    
	寄存器变量
       
	静态变量，静态变量完成工作时，并不消失。
      外部链接静态变量
	     可以自动初始化
      内部链接静态变量
	  空链接静态变量
  
存储类型说明符
auto，
register， 
static，
   作用域代码块时，使得变量具有静态存储时期，从而得以在程序运行期间存在并保留其值。
   仍然具有代码块作用域和空链接
   作用域文件作用域时，表明该变量具有内部链接。
extern，
   文件作用域，外部链接
   代码块作用域，外部链接，内部链接都有可能。
typedef

程序编译时，给静态变量分配内存，并在程序运行时一直保持。
程序执行时，给自动存储时期的变量分配内存，并在代码结束时释放这部分内存。

##存储与函数##
  static 就是限定一个特定模块所私有的函数。
  
  随机函数 和 静态变量
    time.h
	srand((unsigned int)time(0));
  
##分配内存##
  C可以在程序运行时分配更多的内存
  malloc（）返回所需内存第一个字节的地址，char代表一个字节，传统上将
  malloc定义为指向char的指针类型。如果找不到所需空间，将返回空指针。
  ANSI C 标准使用了一个新类型，指向void的指针。
         double *ptd;
		 ptd=(double *)malloc(30 * sizeof(double));
          //ptd为指向一个double类型值的指针声明
		  // 数组名字是它第一个元素的地址，ptd指向一个内存块的第一个元素，
		  // 就可以像使用数组名字一样使用ptd， ptd[0]，ptf[1]

  free（）的参数为先前malloc（）返回的地址。
  calloc（） 将块中全部位置为0

##变长数组##
  变长数组 可以用来创建一个大小在运行时决定的数组。
  VLA 自动存储，自动释放空间。


##const##
   volatile 告诉编译器 该变量除了可被程序改变以外还可以被其他代理改变
   restrict 优化指针，表明指针是访问一个数据对象的唯一且初始的方式，满足了不可有重叠的要求
  const float  *pf  ， const float *pf 指向的值必须不变

  float * const pt 一个常量指针 指向同一个地址
  const float * const ptr 指向同一个位置，并且所指存储的值也不能变

  void display（const int array[]， int limit）
  const int array 与 const int * array 表明指向数据不变

#*******************************************************************************
#2.基础
#*******************************************************************************
#
#2-1.逻辑 ，运算，分支，循环
#2-2.数组
#2-3.函数

#
    文件结尾
 	    如今操作系统可以使用一个内嵌的Ctrl+Z字符来标志文件结尾
	    根据操作系统存储文件大小的信息，Unix对所有文件都使用此方法
    
	    对于这两种不同的方法，C的处理方法是让getchar 函数在到达文件结尾时
	    返回一个特殊值，而不去管操作系统是如何检测文件结尾的。赋予该值的名称是EOF
		（End Of File，文件尾） 在stdio.h中，#define EOF (-1),这个值是代表了文件尾的意思

#*******************************************************************************
#3.字符串 和 字符串函数
#*******************************************************************************
# 
# 字符串 是以空字符 \0 结尾的char数组
  字符串常量 字符串文字，是指位于一对双引号中的任何字符。双引号里的字符加上编译器
  自动提供的结束标志\0字符，作为一个字符串被存储在内存里。
#
# 数组与指针
  数组形式，在内存中分配一个有N（N为数组长度）元素的数组，其中每个元素对应一个
  字符，还有一个附加元素对应结束的空字符'\0',每个元素都被初始化为相应的字符。
 
    通常被引用的字符串存储在可执行文件的数据段部分，当程序被加载到内存中时，
	字符串被加载到内存中被称为位于静态存储区。程序开始运行后才为数组分配存储空间。
    在这时把被引用的字符串复制到数组中，编译器把数组名看作是数组首元素的地址，数组名
    为一个常量。
 
  指针形式，也在静态存储区为字符串预留元素空间，程序开始还要为指针变量预留一个
  存储空间，存储字符串的地址。这个变量初始时指向字符串的第一个字符。
  指针只是复制字符串的地址。
# 
########
  gets 函数
  从一个系统的标准输入设备获得一个字符串，读取字符串直到遇到换行符
  gets函数的一个不足是它不检查预留存储区是否能够容纳实际输入的数据。

  fgets 函数
  scanf 函数

  puts 函数
  fputs
  printf

  strlen 函数，可以得到字符串的长度。
  strcat 函数 strncat
  strcmp 
  strcpy 复制字符串本身
  sprintf 函数 把字符串写到字符串里面

#
#3-1.字符串（一个或多个字符的序列）
  双引号 不是字符串的一部分，它们只是通知编译器其中包含了一个字符串

  char数组类型 与 空字符
    C没有存储字符串定义专门的变量类型，把它存储在char数组中。
  字符串中的字符存放在相邻的存储单元中，每个字符占用一个单元。
  数组中的最后一个位置显示字符\0，这个字符是空字符（null character），C用它来标记
  字符串的结束。空字符不是0，非打印字符，其ASCII码的值为0 

  字符串 和 字符
   字符   属于基本类型 char
   字符串 属于派生类型 char数组
          字符串结尾为空字符\0
#
#3-2.常量 和 C预处理器
   明显常量：C预处理器，当编译程序时，value将会在定义的常量出现的每个地方代替它。
   #define Name value 符号名后的所有内容都被用来代替它的

   C90 新增const，把一个变量转换层常量声明
   limits.h 
   float.h
#
#*******************************************************************************
# 4.输入 输出
#*******************************************************************************
#
#4-1.I/O函数
    最通用的I/O函数，不是只有可以使用的C I/O函数，不为C定义的一部分
	C把I/O的实现留给了编译器的编写者。

	printf() 函数
	  1） 转换说明符 实际就是翻译说明
	      %d 是把给定的值翻译成十进制整数文本表示
      2） 调用时告诉计算机把变量的值传递给计算机，把它们放置到被称为堆栈的一块内存区域
	      中实现，计算机根据变量的类型把这些值放到堆栈中，读取的时候按照转换说明符去读取
	scanf()  函数
    
	面向字符的I/O函数
	getchar()  它返回来自输入设备的下一个字符
	putchar()
	ctype.h 系列字符函数

# 
#4-2.文件输入，输出
    一个文件 file 通常就是磁盘上的一段命名的存储区。C将文件看成是连续的字节序列。
   
#4-3.标准I/O
    1).命令行参数
	2).exit（）函数关闭所有打开文件并终止程序。
	3).文件指针 是一种指向FILE的指针，FILE是stdio.h中定义的一种派生类型。
	             指针fp并不指向实际的文件，而是指向一个关于文件信息的数据包。
       标准文件指针
	       stdin   文件自动打开
		   stdout  文件自动打开
		   stderr  文件自动打开

    4).文件结尾
	   如果在尝试读入字符时发现已经达到文件结尾，getc（）函数会返回EOF
	   C语言程序只有在读取超出文件结尾以后才会发现文件的结尾。
	
	   int ch;
	   FILE *fp;
	   fp=fopen("file.txt","r");
	   while((ch=getc(fp)) != EOF){
		  putchar(ch);
		}
	
	5).二进制模式 和 文本模式
	6). 标准I/O
	    文本流
	    文件中的全部数据都以字符编码的形式被解读，（文件包含文本数据）
	    二进制模式

	    二进制流
        数据部分或者全部以二进制形式的数字数据被解读，（文件包含二进制数据）
        文本模式

		文件输入 stdio.h 中声明的某个输入函数，把一块数据从文件复制到缓冲区
		数据结构和缓冲区初始化以后，输入函数将从缓冲区中读取所请求的数据。文件位置
		指示器被置为紧随最后一个被读取字符的位置。stdio.h定义的所有输入函数都使用
		同一个缓冲区，所以任何一个被调用都将在前一次任何函数调用停止的地方继续开始。
		当输入函数检测到已经读取了缓冲区中的全部内容时，它会请求系统将下一个缓冲区
		大小数据复制到缓冲区。
		输出函数将数据写入缓冲区，当缓冲区已满时，就将数据复制到文件中。


	7).文件I/O
	fopen() 函数 
	         打开文件，并且建立了一个缓冲区。如果是读写模式，将打开两个缓冲区
			 fopen（）函数返回一个文件指针，其他I/O函数用这个指针来指定该文件
             如果不能发开，返回NULL。


	getc() 函数，
	        ch=getc（fp） 从指针fp指定的文件中获得一个字符
	        getchar（）函数， 从标准输入获得一个字符。
	putc() 函数，
            putc（ch，fpout）将ch写入到FILE指针fpout指定的文件中
            putc（ch，stdout） 和 putchar（）
    fclose() 关闭文件，同时根据需要刷新缓冲区。如果成功关闭，返回值0，否则返回EOF
	        if(fclose(fp)!=0){
			  printf("Error in closing file %s\n",argv[1]);	
			}
    fprintf() 
	        作为字符串存储，该函数以一种可能改变数字值的方式将其转换成为字符串。
	fread() 二进制标准I/O，中间没有从数字形式 到 字符串形式的转换。
	        把数据存储在一个使用 与 程序具有相同表示方法的文件中（数据以二进制形式存储）
			一个double值就应该存储在一个double大小的单元中。
	size_t fread(void * restrict ptr,size_t size,size_t nmemb,FILE * restrict fp)
	fscanf()
  	size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp) 
           size_t 是unsigned int 类型
		   ptr    是要写入的数据块的地址
		   size   表示要写入的数据块的大小（以字节为单位）
		   nmemb  表示数据块的数目
		   fp     指定要写入的文件

            char buffer[256];
            fwrite(buffer,256,1,fp);
         
		    double earning[10];
		    fwrite(earning,sizeof(double),10,fp);
            fwrite函数成功的话，返回写入的nmemb数，错误的话，返回小于nmemb数
    int feof(FILE *fp) 如果最近一次输入调用检测到文件结尾，函数返回一个非零值
	int ferror(FILE *fp) 如果发生读写错误，ferror函数返回一个非零值，否则返回零值

	fgets() 函数读取到它所遇到的第一个换行字符后面，或 读取字符串的最大长度少一个的字符
	        或 读取到文件结尾。然后fgets函数向末尾添加一个空字符串以构成一个字符串。
			遇到EOF会返回NULL值，否则，它返回传递给他的地址值。
			gets函数读取换行符后会将其丢掉。fgets不会
	fputs() 函数，把指针所指的字符串写入指定文件。fputs函数打印的时候并不添加一个换行符。
	        puts函数，会添加换行符。
    fseek() 函数
	        第一个参数文件指针，第二参数偏移量，第三个参数模式（long类型）用来表示起始点
			fseek()的返回值为0，如果有错误出现返回值为-1.
	ftell() 函数，为long类型，返回文件的当前位置。
	        通过返回文件开始处的字节数目来确定文件的位置。
			在ANSI C 下，这种定义适用于以二进制模式打开的文件，但是对于以文本模式打开的文件来讲。
	fgetpos() 
	        fpos_t(file position type 文件定位类型，用来指定文件中的一个位置)  
            int fgetpos(FILE * restrict stream, fpos_t * restrict pos);
    fsetpos()
            int fsetpos(FILE *stream, const fpos_t *pos);
    int ungetc(int c, FILE *fp) 将c指定的字符放回输入流中。
	int fflush(FILE *fp) 将缓冲区中任何未写的数据发送到一个由fp指定的输出文件中去
	int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size)



#*******************************************************************************
# 5.结构
#*******************************************************************************
#
#5.1 结构 
     结构设计告诉编译器如何表示数据，没有让计算机为数据分配空间
     结构声明，初始化，结构数组 
	    struct Name {
		   eles；
		}
	
	结构指针
	结构与函数参数
	结构中的字符串
	结构 malloc 指针


#5.2 联合 同一个空间，存储不同的数据类型
#     枚举 类型， 枚举是常量
#	    enum typename


#5.3 typedef
     是一种高级数据特性，为某一类型创建自己的名字。
	 typedef 的解释由编译器，而不是处理器执行
	 
	 typedef type NewName
     之后，便可以用NewName来定义变量，其作用域根据位置而变
	 


    *  表示一个指针
	() 表示一个函数
	[] 表示一个数组
     () [] ,从左至右结合，优先级相同，并高于*
      
   函数 与 指针
     函数指针：指向函数的指针保存着函数代码其实的地址



#*******************************************************************************
# 6.C处理器 和 C库
#*******************************************************************************
#
# 
  编译程序之前，先有预处理器检查程序（预处理器），预处理器只是一种文本替换，不进行计算
  对程序作预处理前，编译器会对它进行几次翻译处理。
     编译器  
	  1.字符映射 到 源字符集
      2.查找反斜线后紧跟回车键的实例并删除这些实例。将两行物理行转换成一个逻辑行
      3.编译器将文本划分为与处理的token，空白字符 ，注释序列
  最后进入预处理阶段
      预处理寻找可能存在的预处理指令，指令为一行开始#符号标识
  
  #define
    指令定义的作用域从定义开始直到文件的结尾
    或者遇到#undef

    语言符号
       系统把宏的主体当作语言符号token类型字符串。C预处理器中的语言符号是宏主体的单独
       的词。用空白字符把这些词分开。在预处理器中空格只是一个分隔符
    类函数宏
	   用圆括号括起一个或多个参数，随后这些参数出现在替换部分。
	   利用宏参数创建字符串 #x 把参数x字符串化
       预处理的粘合剂 ## 
            #define XNAME(n) x##n   
			XNAME(4) 的结果是 x4

   可变宏 __VA_ARGS__
   预定义宏
       __DATE__ 
	   __FILE__
	   __LINE__
	   __STDC__
	   __STDC_HOSTED__
	   __STDC_VERSION__
	   __TIME__


   #include 
      <> 预处理器一个或多个标准系统目录中寻找文件。
	  "" 告诉预处理器先在当前目录（文件中指定的其他目录）中寻找，然后在标准位置寻找
       
   #undef 取消定义给定的#define
   #ifdef
   #else
   #endif
   #ifndef

   #if 后跟常量整数表达式
   #if define（VAX） 
       define是一个预处理器运算符，如果define的参数已经用#define定义过
	   返回1，否则返回0
   #line 重置__LINE__和__FILE__宏报告的行号和文件名
   #error
   #pragma
    
 内联函数
   编译器将尽可能调用该函数。   
   inline func（）{
     statement；	
   }

   编译器回用内联函数体代替函数的调用

#库
 string.h
     memcpy  复制其他类型的数组
	   void *memcpy(void * restrict s1, const void * restrict s2,size_t n)
	   size_t 指定字节数
	 memmove 
	   void *memmove(void *s1,const void *s2, size_t n)
	 strcpy  函数复制字符数组
	 strncpy 函数复制字符数组
 stdarg.h
     在函数原型中使用省略号
	   void f1(int n, ...)
	 在函数定义中创建va_list类型的变量
	   va_list 用于存放参数列表省略号代表的参量的一种数据对象
       va_list ap;
	 用宏将该变量初始化一个参数列表
       double sum(int lim, ...){
		
	   } 
       lim 为常量parmN
	   va_start() 把参数列表复制到va_list变量中,用两个参数，va_list类型变量 
	   参量parmN  // va_start(ap,lim) 把ap初始化为参数列表  
	 用宏访问这个参数列表
	   va_arg() 该宏接受两个参数
	   一个va_list类型的变量 和 一个类型名,第一次调用时返回第一项，再一次调用
	   返回第二项

	   va_arg(ap,double)
	   va_arg(ap,int)

	 用宏完成清理工作
       va_end(ap) 释放动态分配的用于存放参数的内存
	  
	 // va_copy() 
#*******************************************************************************
# 7.输入 输出
#*******************************************************************************
#



























```
