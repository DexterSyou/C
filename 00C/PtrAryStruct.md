##

```
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0
# 指针 一种保存变量地址的变量
    int * p；
    定义了一个int * 类型的内存空间，有4个字节空间，名字叫p，
	这个连续内存地址的连续4个字节空间只能存储某个int类型数据（内存地址）
	”*“前面的数据类型只能说明指针所指向的内存里存储的数据类型为 int

	int *p = NULL； 初始化指针，p的值设置为0x00000000。而不是*p的值。
	int *p；
	*p = NULL； 这是给*p的值设置为0x00000000

# 指针 与 地址
  机器有一系列连续编号或编址的存储单元，这些单元可以单个进行操纵，也可以以连续成组的方式操纵
  通常，机器的一个字节可以 存放一个char类型的数据
  指针是能够存放一个地址的 一组存储单元（两个字节 或 4个字节）

  内存地址本质也是个指针
  int *p = （int *）0x12ff7c
  * （int *）0x12ff7c = 0x100；

  &可用于取一个对象的地址
  *将访问指针所指向的对象
   & 与 * 
   的优先级比算术运算符优先高

# 指针与函数参数
      C语言是以传值的方式将参数值传递给被调用函数，

# 指针与数组
    数组类型的变量 或 表达式的值 是 该数组第0个元素的地址。
	指针是一个变量，数组名不是变量
	数组名就是第0个元素的地址

	常量NULL 代替 常量0
    
	字符串常量 是一个字符数组，C中并没有进行字符串的复制

	while（（*s++ = *t++）！= ‘\0’ ） 
 	  
# 指针数组： 存储指针的数组
             int * p[10]； 
  数组指针： 指向数组的指针
             int（* p）[10]
			 int（*）[10] p
  “[]” 的优先级比“*” 要高

	static char *name[] = {
      "Illegal month",
      "January", "February", "March", "April", "May", "June",
      "July", "August", "September", "October", "November", "December"
    };

# 指向指针的指针
  
  
# 命令行参数
		argc 参数个数 
		argv 指向 指针数组的 指针
		int main（int argc ，int *argv[]）
# 指向函数的指针
	 可以被赋值，存放在数组中，传递给函数以及作为函数的返回值
      int *f()
	  int (*pf)();

#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0
# 数组
  
# 数组的内存布局
   编译器根据指定的元素个数 和 元素类型分配确定大小的一块内存，这块内存的名字就是数组名
   关键字sizeof求值是在编译的时候，不是在运行时后，函数求值是在运行的时候。
   
   int a[5]
   a是整个数组，代表的是数组首元素的首地址    
   &a数组的首地址
   a[0] 是首元素      &a[0]数组首元素的地址

    // x = y ，编译器认为x的含义是x所代表的地址，这个地址只有编译器知道，在编译的时候确定
    //         编译器认为y的含义是y地址里面的内容，这个内容到运行时才知道
   当a 作为右值是 代表的是数组首元素的地址，不是数组的地址 ， 与&a[0] 一样
   但是编译器并不为数组a分配一块内存来存储其地址

   a不能作为左值

# // 指针就是指针，是一个内存的地址
  // 数组与指针无关，是一块内存
   
  1. char *p = "abcdef";
     定义一个指针变量p，在栈上占4个byte，p里存储的是一块内存的首地址
     这块内存在静态区，其空间大小为7个byte
    
	 访问形式：
     1） *（p+4）
	 2） p[4] 编译器总是把以下标的形式的操作解析为以指针的形式的操作
	          先取出p里存储的地址值，然后加上中括号中4个元素的偏移量，计算出新的地址，
	  		  然后从新的地址中取出值
  2. char a[] = "123456";
     定义一个数组a，拥有7个char类型的元素，其空间大小为7，数组a本身在栈上面
	 *(a+4) a代表的是数组首元素的首地址
	 a[4]   a作为数组首元素的首地址，然后加上括号中4个元素的偏移量，计算出新的地址 
     取a[i]的内容：
	    计算a[i]的地址：首元素的地址+i*sizeof（char）
		取计算处地址中的内容
			
########################
# 指针和数组的定义与说明
#1  file1: char a[100]；
    file2: extern char *a；

#2  file1: char *p = ”abcdefg“；
    file2: extern char p[]
    编译器把p当作包含4个char类型的数组来使用


#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0

# 结构
 struct struct_tag {
	  type mem1;
	  type mem2;
	};

#联合
 union bits32_tag{
	   int whole;
	   struct { char c0, c1,c2,c3;} byte;}
	}value; 

#枚举
 enum tag { content } var；


 


#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0
# 定义结构变量
struct book {
	char title[5];
	float value;
} library;

