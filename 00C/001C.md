##

```
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#Thompson 为PDP-7编写了一个简易的新型操作系统，BrianKernighan在1970年给他取名UNIX
#Thompson 创建了B语言，简化BCPL，使B的解释器常驻PDP-7，
#Dennis Ritchie 在利用PDP-11的强大性能，创立了能够同时解决多种数据和效率的New B
#它采用了编译模式而不是解释模式，并引入了类型系统
#C的特性是为了方便编译器而设计的
#标准I/O函数库
#C预处理器
#   字符串替换
#   头文件包含 （BCPL 中首创
#   通用代码模版扩展
#   ）
#1978 K&R C
#ANSI C
#用于描述编译器的特点
  不可移植的代码 unportable code
      由编译器定义的implementation-define
	      由编译器设计者决定采取这种行动
	     （在不同的编译器中所采取的行为可能并不相同，但它们都是正确的）
      未确定的unspecified 
	      在某些正确情况下的做法，标准并未明确规定应该怎样做
  坏代码 bad code
     未定义的undefined 
	      在某些不正确情况下的做法，但标准并未规定应该怎样做，你可以采取任何行动
     约束条件 a constraint 
	      必须遵守的限制 或 要求，不遵守，程序的行为就会变成未定义的。
标准规定只有在违反语法规则 和 约束条件的情况下才能产生错误信息。
不遵守的约束条件属于未定义，编译器可以做任何处理。
   可移植代码 protable code
      严格遵循标准strictly-conforming
          只使用已确定的特性
	      不突破任何编译器实现的限制
	      不产生任何依赖由编译器定义的 或 未确定 为定义的特性输出
      遵循标准的 conforming
	      一个遵循标准的程序可以依赖一些某种编译器特有的不可移植特性 
          
  #pragma 指示符，用与向编译器提示一些信息
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
# C 语言特性
#-------------------
#switch 允许标签存在，无法检测出打错了字，比如case 达成caes
 break用于跳出switch语句 与 循环
#ANSI C 相邻字符串常量将被自动合并成一个字符串的约定
 在字符串数组初始化时，得注意逗号是否被漏掉
#太多的缺省可见性
 定义C函数时，在缺省情况下函数的名字时全局可见的


#-------------------























#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#-------------------
#关键字
#--------------------
#1. 定义：编译器 创建一个对象，为这个对象分配一个内存并给它取个名字
          一个对象在一定的区域内只能被定义一次
	声明：告诉编译器，这个名字已经匹配到一块内存上了，下面的代码用到变量或对象是在别的地方定义的。可多次出现
	      告诉编译器，这个名字我先预定了，别的地方不能用它来做变量 或 对象
#2. 编译器默认缺省情况下，所有变量的都是auto
#3. register请求编译器尽可能的将变量存在CPU 内部寄存器中，而不是通过内存寻址访问以提高效率 。
#4. static
    修饰变量。变量又分为局部和全局变量，但它们都存在内存的静态区。
	静态全局变量，作用域仅限于变量被定义的文件中，其他文件即使用extern 声明也没法使用他。
 	准确地说作用域是从定义之处开始，到文件结尾处结束，在定义之处前面的那些代码也 不能使用它。
    静态局部变量，在函数体里面定义的，就只能在这个函数里用了，同一个文档中的其他函数也用不了。
	由于被static修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值还是不会被销毁，
	函数下次使用时仍然能用到这个值。

    修饰函数，成为静态函数。函数的作用域仅局限于本文件(所以又称内部函数)。
    类似私有函数
#5. 数据类型
	整形
	浮点型
	字符 char

	数组
	结构体
	共用体（联合）
	枚举类型
	
	指针类型
	空类型 void
#6.sizeof
   int i=0;
   sizeof i
   sizeof(i)
   sizeof(int)
#7.编译器缺省默认下为signed类型
#8.FALSE 一般编译器都定义为0，TRUE不一定为1
   float [0.0-EPSINON，0.0+EPSINON]
   判断空指针变量比较 NULL == p ， NULL ！= p
#9.switch...case
   case  后面只能是整形 或 字符型的常量 或 常量表达式
#10.void 修饰函数返回值，参数
    void 指针
	void 不代表真实变量
    
    const readonly
	const 定义只读变量，具有不可变性，编译器不为const只读分配存储空间，而是将它们保存在符号表中
	全局只读变量，存在静态区，在程序运行中只是一份拷贝，在编译时确定其值
	修饰一般变量
	int cosnt i=2; const int i=2;
	修饰数组（一个只读数组）
	int const a[5]={1,2,3,4,5}
	const int a[5]={1,2,3,4,5}
	修饰指针
	const int *p;         p可变， *p（p指向对象）不可变
	int const *p;         p可变， *p不可变
	int * const p;        p不可变，*p指向的对象可变 
    const int * const p;  都不可变

	修饰函数参数，参数不可被函数体内改变
    修饰函数返回值，返回值不可被改变

#11.volatile
#12.extern 表示变量 或函数的定义在别的文件中
#13.struct 
    编译器为每个结构体类型数据预留1个byte的空间
	union
	维护足够的空间来置放多个数据成员中的 一种，所有数据成员共享一个空间
	同一时间只能存储其中一个数据成员，所有的数据成员具有相同的起始地址
	一个union只配置一个最大的内存空间来容纳最大长度的数据成员，都是从union
	的首地址位置开始读取数据
#14.大小端模式
	Big_endian      字数据的高字节存储在低地址中，低字节存储在高地址中
	Little_endian   字数据的高字节存储在高地址中，低字节存放在低字节中 
#15.enum enum_type_name {
      ENUM_CONST_1,
      ENUM_CONST_2,
       ...
      ENUM_CONST_n
    } enum_variable_name;
    enum_type_name 是自定义的一种数据数据类型名
	enum_variable_name 为enum_type_name类型的一个变量
    enum_type_name类型是对一个变量取值范围的限定，而花括号内是它的取值范围，
	即 enum_type_name 类型的变量enum_variable_name 只能取值为花括号内的任何一个值
    enum 变量类型还可以给其中的常量符号赋值，如果不赋值则会从被赋初值的那个常量开始依次加1，
	如果都没有赋值，它们的值从0 开始依次递增1。
枚举与 #define 宏的区别：
    #define 宏常量是在预编译阶段进行简单替换。枚举常量则是在编译的时候确定其值。    
#16.typedef
	给一个已经存在的数据类型取一个别名
	typedef struct student
    {
      //code
    }Stu_st,*Stu_pst;
    struct student {/*code*/} *‛是一个整体
typedef  与 #define 的区别

#-------------------
#指针 和 数组
#-------------------






    
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
#*********1*********2*********3*********4*********5*********6*********7*********8*********9*********05
```
