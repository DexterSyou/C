##

```
1. shell
2. 文件系统
   第一级目录为根目录，根目录包含 文件 和 子目录
   每个存储设备都有一个独自的文件系统

   pwd ( print working directory 显示当前工作目录
   ls  ( List directory contents
       ls /usr
       ls ～ /usr
   cd  ( change directory
      cd - 到先前的工作目录
      .  当前目录
      .. 父目录  
   
3. 
  file ( Determine file type  确定文件类型
  less ( view file contents   浏览文件内容

4. 操作文件和目录
   cp ，mv ，rm
     cp item1 item2
     cp item1... directory
     当使用rm删除时，先用ls确定要删除的文件
   mkdir directory ...
     mkdir d1 d2 d3
   ln  
     ln file link
         一个硬链接不能关联与链接本身不在同一个磁盘分区上的文件
         一个链接不能关联一个目录
     ln -s item link
        一个符号链接指向一个文件
 
  通配符
   *
   ？
   [characters] 匹配任意一个属于字符集的字符
   [！characters]  
   [[：class：]]
    [:alnum:]  匹配任意一个字母 或 数字
    [:alpha:]  匹配任意一个字母
    [:digit:]  匹配任意一个数字 
    [:lower:]  匹配任意一个小写字母
    [:upper:]  匹配任意一个大写的字母

5. 使用命令
  type     说明怎样解释一个命令名
     显示命令的类别
     type type
     type is a shell builtin
     type ls
     ls is hashed (/bin/ls)
  which    显示会自行那个可执行程序
  man      显示命令手册
  apropos  显示一系列适合的命令
  info     显示命令info
  whatis   显示一个命令简洁的描述 
  alias    创建命令别名 
     alias name=“string”
     unalias name

6.重定向
  6.1 标准输入stdin  0 => 默认情况下，链接键盘
      标准输出stdout 1，标准错误stderr 2（状态信息）=> 默认情况下，二者都连击到屏幕
      * 重定向允许我们更改输出地点 和 输入来源，重定向不把错误信息送到标准输出
   demo： 
   1)   > file1    
          命令可以清空文件或创建一个空文件
   2)   >>         
          输出结果添加到文件内容
   3)   ls  -l ./  > ls-output.txt 2>&1
        ls  -l ./  &> ls-output.txt
   4)   /dev/null    
          系统设备，位存储桶，可以接受输入，并且对输入不做任何处理
       ls -l  ./ 2> /dev/null  
          不想要输出结果 
  6.2
   cat [file] 连接文件
      读取一个 或 多个文件，然后复制它们到标准输出
      如果只输入cat， 他会从标准输入读入数据，标准输入默认连接键盘，它等待我们输入数据
   demo：          
   1）  cat movie.mpeg.0* > movie.mpeg
   2）  cat     
        cat > test1.txt
   3） < 
        将标注输入源改变位其他地方
  
   command1  | command2 一个命令的标准输出可以送到另一个命令的标准输出 
   demo：
   1） ls -l /usr/bin | less
   2） ls /bin /usr/bin | sort | less
   3） ls ./ | sort | uniq | less 
       uniq 和 sort 命令结合使用，删除重复行
       uniq -d 可以显示重复数据列表

   wc 显示文件所包含的行数，字数和字节数
      如果wc不带参数，它接受标准输入 -l选项限制命令输出只能报道行数

   grep pattern [file ...] 
      -v
      -i
   head 
   tail    
      ls /usr/bin | tail -n 5 输出后5行
      tail -f 实时监测浏览文件

   tee 
     从stdin读取数据，并同时输出到stdout和文件
     捕捉管道内容
     ls /usr/bin | tee ls.txt | grep zip
   
7. 
  每当输入一个命令并按下enter键，bash会在执行你的命令之前对输入命令完成几步处理
  echo  将文本参数打印到标准输出上
 
  1) echo * 
      在执行命令前，把*展开成另外的东西，echo的实际参数是展开后的结果
      通配符所以来的机制是路径名展开
    ls -d .[!.]?*

  2) ~ 展开指定用户的家目录，如果没有指定用户，则展开当前用户的家目录  
   
  3）算术表达式展开
     $((expression))
  
  4) 花括号展开
    echo num_{1..5}
    echo num_{A{1,2},B{1,2}}

  5) 参数展开     
    echo $USER
    prinenv | less
      
  6) 命令替换展开
    echo $(ls)
  
    ls -l $(which cp)
    ls -l `which cp`
  
    file $(ls /usr/bin/* | grep zip)

  7) 引用
   单词分隔机制，会在单词中寻找空格，制表符，换行符，并把它们看作单词之间的界定符
  
   如果把文本放入双引号中，shell使用的特殊字符都失去它们的特殊含义，被当作普通字符来看待
   这意味着，单词分隔，路径名展开，波浪线展开，花括号展开都失效
             参数展开，算术展开，命令替换 仍然执行

   如果使用单引号，我们要是使用单引号

   转义字符 \ 

8.权限
  多用户系统
 8.1 读入，写入，执行
  ls -l foo.txt
  -rw-rw-r--  1  me  me  0  2008-03-06 14:52  foo.txt
  
  -            文件属性  
  rw- rw- r--  文件模式 （文件所有者 文件组所有者 其他人）  
  1           
  me  
  me  
  0  
  2008-03-06 14:52  
  foo.txt
 
 8.2 更改文件模式
  更改目录或文件模式（权限），可以利用chmod命令
  000 ---  0 
  001 --x  1
  010 -w-  2
  100 r--  4

  u user ，g group ，o others ，a all 
  u+x
  go=rw
  +x  等价于 a+x

  u+s
  g+s
  +t

 8.3 设置默认权限 umask
  umask 删除一个位掩码
  mask  ：   000  000  010  010
  result：   ---  rw-  r--  r--
  二进制1的位置相对应地属性被删除
  
 8.4
  su [-[l] shell ]以其他用户身份 和 组ID运行一个shell
  su -  启动超级用户
  su -c ‘command’ 命令传递到一个新shell中执行

  sudo 以另一个用户身份执行命令
       sudo不会重新启动一个新的shell，也不会加载另一个用户的shell环境

 8.5 更改文件所有者 和 用户组
   chown [owner][：[group]] file...
   sudo chown tony：testfile 文件所有者改为tony，用户组改为用户tony登陆系统时所属的用户组
   
 8.6  更改用户组所有权    
   chgrp 

9.进程
  Linux内核通过使用进程来管理多任务
  进程：Linux组织安排正在等待使用CPU的各种程序的方式
  
  ps 查看进程
    默认情况下，列出与当前终端会话相关的进程
  ps x    查看所有进程
  ps aux  

  top            动态查看进程
  xlogo &        把一个进程放在后台执行
  jobs           从我们终端中启动的任务的方法
  fg %任务号     进程返回到前台
     ------
     jobspecs
 
  kill [-signal] PIR... kill命令给进程发送信号
  killall [-u user] [-signal] name... 

  默认发送TERM（Terminate 终止）信号
     xlogo &
     [1] 13546
     kill -l 13546

  TSTP Ctrl+z    终端停止
  SEGV           段错误， 非法使用内存
  QUIT           退出
  

  kill -l 得到完整信号列表
  




```
