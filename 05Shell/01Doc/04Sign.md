## 控制脚本

```
---------0---------1---------2---------3---------4---------5---------6---------7---------8---------9
1/ 进程
   程序运行在系统上-->process 进程
   ps

   结束进程
   kill
   killall



---------0---------1---------2---------3---------4---------5---------6---------7---------8---------9
2/ 信号
   1  SIGHUP   挂起进程
   2  SIGINT   终止进程
   3  SIGQUIT  停止进程
   9  SIGKILL  无条件终止进程
   15 SIGTERM  尽可能终止进程
   17 SIGSTOP  无条件停止进程，但不是终止进程
   18 SIGTSTP  停止或暂停进程，但不终止进程
   19 SIGCONT  继续运行停止的进程

   #1）生成信号
       Ctrl+C 生成SIGINT信号，并将其发送给当前在shell中运行的所有进程
       Ctrl+Z 生成SIGTSTP
             shell 将shell中运行的每个进程称为作业
	         ps -l 查看已经停止的作业 （S列标记为T）
			 kill -9 PID 可以终止已经停止的作业
   #2）捕获信号
       trap commands signals
       信号出现时捕获它们并执行其他命令
	   trap “echo 'xxxyyyzzz' ” SIGINT
   #3) 捕获脚本并退出
       trap commands EXIT

	   trap -- signals #删除信号

---------0---------1---------2---------3---------4---------5---------6---------7---------8---------9
3/ 后台模式
   后台模式中，进程运行时不会和终端会话上的STDIN，STDOUT，STDERR
   
   commands &

   后台进程与终端会话终端联系在一起。
   有时即使退出了终端会话，也一直运行。
   nohup命令 运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。在退出终端会话时
   阻止进程退出，由于nohup命令会解除终端与进程的关联，进程也就不与STDOUT和STDERR联系在一起
   nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为nohup.out的文件中

---------0---------1---------2---------3---------4---------5---------6---------7---------8---------i
4/ 作业控制
   #1. jobs -lnprs  查看shell当前正在处理的作业
      （当前+默认的作业，只有一个）-----> 完成处理后-----> （-的作业，只有一个）
	   ----->变成了（+下一个默认作业）
   
   #2. 重启作业
      bg 加作业号
         以后台模式重启一个作业
      fg 加作业号
         以前台模式运行的，直到该作业完成后，命令行界面的提示符才会出现
  
   #3. nice
       nice命令允许你设置命令启动时的调度优先级。
       nice命令阻止普通系统用户来提高命令的优先级。

       renice 指定运行进程的PID来改变它的优先级。 
       renice命令会自动更新当前运行进程的调度优先级。
	   和nice命令一样，renice命令也有一些限制:   
          只能对属于你的进程执行renice;
		  只能通过renice降低进程的优先级;
          root用户可以通过renice来任意调整进程的优先级。

---------0---------1---------2---------3---------4---------5---------6---------7---------8---------9
5/ 定时作业
   #1. at [-f filename] time
       默认情况下，at命令会将STDIN的输入放到队列中，-f参数来指定用于读取命令的文件名
	   time参数指定Linux系统何时运行该作业

      （1）
	   at命令把作业提交到作业队列中，作业队列会保存通过at命令提交的待处理的作业。
	   at的守护进程atd会以后台模式运行，检查作业队列来运行作业。
	   atd守护进程会检查系统上的一个特殊目录(通常位于/var/spool/at)来获取用at命令提交的作业。
	   默认情况下，atd守护进程会每60秒检查一下这个目录。
	       有作业时，atd守护进程会检查作业设置运行的时间。
		   如果时间跟当前时间匹配，atd守护进程就会运行此作业。


       针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a~z 和大写字母A~Z来指代。
	   作业队列的字母排序越高，作业运行的优先级就越低(更高的nice值)。
	   默认情况下，at的作业会被提交到a作业队列。
	   如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。

       
	  （2）作业输出
	   Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR。
	   任何发到STDOUT或STDERR的输出都 会通过邮件系统发送给该用户。
       
	   at命令利用sendmail应用程序来发送邮件 
	   在使用at命令时，最好在脚本 中对STDOUT和STDERR进行重定向

      （3）atq命令可以查看系统中有哪些作业在等待
      （4）用atrm命令来删除等待中的作业
	       atrm 作业号

    #2. 定期执行
	    Linux系统使用cron程序来安排要定期执行的作业。
		cron程序会在后台运行并检查一个特殊的表(被称作cron时间表)，以获知已安排执行的作业。
       
       （1）cron时间表采用一种特别的格式来指定作业何时运行。其格式如下:
            min hour dayofmonth month dayofweek command
           
		    cron时间表允许你用特定值、取值范围(比如1~5)或者是通配符(星号)来指定条目
            dayofmonth表项指定月份中的日期值(1~31)
		    dayofweek表项
		        三字符的文本值(mon、tue、wed、thu、fri、sat、sun)或数值(0为周日，6为周六)
			
			    # 设置一个在每个月的最后一天执行的命令
				# 00 12 * * * if [`date +%d -d tomorrow` = 01 ] ; then ; command
 
            可以像在普通的命令行中那样，添加 任何想要的命令行参数和重定向符号。
       
        （2）每个系统用户(包括root用户)都可以用自己的cron时间表来运行安排好的任务
		     Linux提供 了crontab命令来处理cron时间表

			 crontab -l

			 预配置的cron脚本目录
			 有4个 基本目录:hourly、daily、monthly和weekly
             ls /etc/cron.*ly


             anacron程序 如果anacron知道某个作业错过了执行时间，它会尽快运行该作业
			             这意味着如果Linux系统 关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行。
             anacron程序只会处理位于cron目录的程序

---------0---------1---------2---------3---------4---------5---------6---------7---------8---------9
当用户登入bash shell时需要运行的启动文件
基本上，依照下列顺序所找到的第一个文件会被运行，其余的 文件会被忽略:
$HOME/.bash_profile 
$HOME/.bash_login 
$HOME/.profile
登录时运行的脚本放在上面第一个文件中。
每次启动一个新shell时，bash shell都会运行.bashrc文件。


---------0---------1---------2---------3---------4---------5---------6---------7---------8---------9
```
